<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <!-- Responsive viewport for mobile devices [oai_citation:0‡gamedevjs.com](https://gamedevjs.com/articles/best-practices-of-building-mobile-friendly-html5-games/#:~:text=,works%20well%20on%20different%20devices) -->
<style>
html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    touch-action: none; /* disable browser scrolling on touch gestures */
}
canvas {
    position: absolute;
    top: 0;
    left: 0;
    touch-action: none;
}
#gameCanvas {
    z-index: 1;
}
#uiCanvas {
    z-index: 2;
}
#settingsPanel {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 3;
    background: rgba(255,255,255,0.9);
    padding: 10px;
    border-radius: 8px;
    font-family: sans-serif;
    max-width: 320px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}
#settingsPanel h3 {
    margin: 0 0 6px 0;
    font-size: 16px;
}
#settingsPanel .section-title {
    font-weight: bold;
    margin-top: 6px;
}
#settingsPanel label {
    display: block;
    margin: 4px 0;
    font-size: 13px;
}
</style>
</head>
<body>
<div id="settingsPanel">
    <h3>Settings</h3>
    <div class="section-title">Controls</div>
    <label><input type="checkbox" id="enableJoystick" checked> Enable joystick</label>
    <label><input type="checkbox" id="enableArrowKeys" checked> Enable arrow keys</label>
    <label><input type="checkbox" id="enableWASD" checked> Enable WASD</label>
    <label><input type="checkbox" id="keyboardJoystickIndicator" checked> Arrow keys show joystick direction</label>
    <div class="section-title">Handedness</div>
    <label><input type="radio" name="handedness" value="right" checked> Right-handed (joystick left)</label>
    <label><input type="radio" name="handedness" value="left"> Left-handed (joystick right)</label>
    <div class="section-title">Content</div>
    <label><input type="checkbox" id="enableWeapons" checked> Show handheld weapons (mature)</label>
</div>
<canvas id="gameCanvas"></canvas>
<canvas id="uiCanvas"></canvas>
<script>
(function() {
    // Get canvases and contexts
    const gameCanvas = document.getElementById('gameCanvas');
    const uiCanvas = document.getElementById('uiCanvas');
    const gameCtx = gameCanvas.getContext('2d');
    const uiCtx = uiCanvas.getContext('2d');
    // Game state variables
    let player = { x: 100, y: 100, radius: 10, speed: 2, color: 'blue' };
    const enemies = [];
    let killCount = 0;
    let mission = 1; // 1: eliminate enemies, 2: reach zone
    const targetZone = { x: 200, y: 200, size: 50 }; // target zone for mission 2
    let attackPressed = false;
    const settings = {
        enableJoystick: true,
        enableArrowKeys: true,
        enableWASD: true,
        keyboardJoystickIndicator: true,
        handedness: 'right',
        enableWeapons: true
    };
    const formRefs = {
        enableJoystick: document.getElementById('enableJoystick'),
        enableArrowKeys: document.getElementById('enableArrowKeys'),
        enableWASD: document.getElementById('enableWASD'),
        keyboardJoystickIndicator: document.getElementById('keyboardJoystickIndicator'),
        enableWeapons: document.getElementById('enableWeapons'),
        handednessRadios: Array.from(document.querySelectorAll('input[name="handedness"]'))
    };
    // Keyboard input
    const keyState = { up: false, down: false, left: false, right: false };
    // Joystick control variables
    // Virtual joystick base (movement control) [oai_citation:1‡gamedevjs.com](https://gamedevjs.com/articles/best-practices-of-building-mobile-friendly-html5-games/#:~:text=,provides%20a%20great%20user%20experience) [oai_citation:2‡gamedevjs.com](https://gamedevjs.com/articles/best-practices-of-building-mobile-friendly-html5-games/#:~:text=,easy%20to%20understand%20to%20ensure)
    let joystickTouchId = null;
    let joystickBase = { x: 80, y: 80 };
    let joystickRadius = 50; // joystick base radius (large for touch) [oai_citation:3‡gamedevjs.com](https://gamedevjs.com/articles/best-practices-of-building-mobile-friendly-html5-games/#:~:text=,easy%20to%20understand%20to%20ensure)
    let joystickKnob = { x: 80, y: 80 };
    const maxSpeed = 3;
    let joystickActive = false;
    // Action button (e.g., attack)
    let actionTouchId = null;
    let actionButton = { x: 0, y: 0, radius: 30 }; // action button radius (large for touch) [oai_citation:4‡gamedevjs.com](https://gamedevjs.com/articles/best-practices-of-building-mobile-friendly-html5-games/#:~:text=,easy%20to%20understand%20to%20ensure)

    function setControlPositions() {
        const joystickOffset = 80;
        const actionOffset = 80;
        if(settings.handedness === 'right') {
            joystickBase.x = joystickOffset;
            actionButton.x = window.innerWidth - actionOffset;
        } else {
            joystickBase.x = window.innerWidth - joystickOffset;
            actionButton.x = actionOffset;
        }
        joystickBase.y = window.innerHeight - joystickOffset;
        actionButton.y = window.innerHeight - actionOffset;
        joystickKnob.x = joystickBase.x;
        joystickKnob.y = joystickBase.y;
    }

    // Resize canvases for device resolution (Hi-DPI support)
    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        gameCanvas.width = window.innerWidth * dpr;
        gameCanvas.height = window.innerHeight * dpr;
        gameCanvas.style.width = window.innerWidth + 'px';
        gameCanvas.style.height = window.innerHeight + 'px';
        gameCtx.setTransform(1, 0, 0, 1, 0, 0);
        gameCtx.scale(dpr, dpr); // scale context for Hi-DPI [oai_citation:5‡gist.github.com](https://gist.github.com/callumlocke/cc258a193839691f60dd#:~:text=%2F%2F%201,ratio)
        uiCanvas.width = window.innerWidth * dpr;
        uiCanvas.height = window.innerHeight * dpr;
        uiCanvas.style.width = window.innerWidth + 'px';
        uiCanvas.style.height = window.innerHeight + 'px';
        uiCtx.setTransform(1, 0, 0, 1, 0, 0);
        uiCtx.scale(dpr, dpr);
        // Recompute control positions
        setControlPositions();
        // Keep player visible
        player.x = Math.max(player.radius, Math.min(window.innerWidth - player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(window.innerHeight - player.radius, player.y));
        clampEnemiesToScreen();
        adjustEnemyCount();
    }
    window.addEventListener('resize', resizeCanvas);
    
    // Generate initial enemies
    const enemyStyles = [
        { type: 'grunt', bodyColor: '#c0392b', headRadius: 5, bodyLength: 14, armLength: 10, legLength: 12, hatType: 'triangle', hatColor: '#1abc9c', weapon: 'gloves' },
        { type: 'brute', bodyColor: '#8e44ad', headRadius: 6, bodyLength: 18, armLength: 12, legLength: 14, hatType: 'square', hatColor: '#2980b9', weapon: 'sword' },
        { type: 'scout', bodyColor: '#e67e22', headRadius: 4, bodyLength: 12, armLength: 11, legLength: 16, hatType: 'pentagon', hatColor: '#16a085', weapon: 'cup' }
    ];

    function pickEnemyStyle() {
        return enemyStyles[Math.floor(Math.random() * enemyStyles.length)];
    }

    function computeEnemyCount() {
        const area = window.innerWidth * window.innerHeight;
        if(area < 450000) return 7;
        if(area < 900000) return 10;
        return 14;
    }

    function adjustEnemyCount() {
        const desired = computeEnemyCount();
        if(enemies.length > desired) {
            enemies.splice(desired, enemies.length - desired);
        } else {
            for(let i = enemies.length; i < desired; i++) {
                const style = pickEnemyStyle();
                spawnEnemy(style);
            }
        }
    }

    function spawnEnemy(style) {
        const ex = Math.random() * window.innerWidth;
        const ey = Math.random() * window.innerHeight;
        const evx = (Math.random() - 0.5) * 2;
        const evy = (Math.random() - 0.5) * 2;
        const hitRadius = Math.max(style.headRadius + style.bodyLength * 0.5, style.legLength);
        const hand = Math.random() > 0.5 ? 'left' : 'right';
        enemies.push({ x: ex, y: ey, dx: evx, dy: evy, size: hitRadius, color: style.bodyColor, style, hand });
    }

    function initEnemies() {
        enemies.length = 0;
        const count = computeEnemyCount();
        for(let i = 0; i < count; i++) {
            const style = pickEnemyStyle();
            spawnEnemy(style);
        }
    }

    function clampEnemiesToScreen() {
        for(const enemy of enemies) {
            enemy.x = Math.max(enemy.size, Math.min(window.innerWidth - enemy.size, enemy.x));
            enemy.y = Math.max(enemy.size, Math.min(window.innerHeight - enemy.size, enemy.y));
        }
    }
    
    // Handle pointer events on uiCanvas (touch-friendly controls)
    uiCanvas.addEventListener('pointerdown', function(e) { // use touch/pointer events for mobile controls [oai_citation:6‡gamedevjs.com](https://gamedevjs.com/articles/best-practices-of-building-mobile-friendly-html5-games/#:~:text=,instead%20of%20the%20click%20event)
        e.preventDefault(); // prevent page scrolling/zooming when using controls
        const rect = uiCanvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        // Joystick control
        const dx = px - joystickBase.x;
        const dy = py - joystickBase.y;
        if(settings.enableJoystick && joystickTouchId === null && dx*dx + dy*dy <= joystickRadius*joystickRadius) {
            joystickTouchId = e.pointerId;
            joystickActive = true;
            // Update joystick knob position
            joystickKnob.x = px;
            joystickKnob.y = py;
        }
        // Attack button control
        const dax = px - actionButton.x;
        const day = py - actionButton.y;
        if(actionTouchId === null && dax*dax + day*day <= actionButton.radius*actionButton.radius) {
            actionTouchId = e.pointerId;
            attackPressed = true;
        }
    });
    
    uiCanvas.addEventListener('pointermove', function(e) {
        e.preventDefault();
        const rect = uiCanvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        if(settings.enableJoystick && joystickTouchId === e.pointerId) {
            const dx = px - joystickBase.x;
            const dy = py - joystickBase.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > joystickRadius) {
                joystickKnob.x = joystickBase.x + dx / dist * joystickRadius;
                joystickKnob.y = joystickBase.y + dy / dist * joystickRadius;
            } else {
                joystickKnob.x = px;
                joystickKnob.y = py;
            }
        }
        if(actionTouchId === e.pointerId) {
            attackPressed = true;
        }
    });
    
    uiCanvas.addEventListener('pointerup', function(e) {
        e.preventDefault();
        if(e.pointerId === joystickTouchId) {
            joystickTouchId = null;
            joystickActive = false;
            // reset joystick knob
            joystickKnob.x = joystickBase.x;
            joystickKnob.y = joystickBase.y;
        }
        if(e.pointerId === actionTouchId) {
            actionTouchId = null;
            attackPressed = false;
        }
    });

    uiCanvas.addEventListener('pointercancel', function(e) {
        if(e.pointerId === joystickTouchId) {
            joystickTouchId = null;
            joystickActive = false;
            joystickKnob.x = joystickBase.x;
            joystickKnob.y = joystickBase.y;
        }
        if(e.pointerId === actionTouchId) {
            actionTouchId = null;
            attackPressed = false;
        }
    });

    function syncSettingsFromUI() {
        settings.enableJoystick = formRefs.enableJoystick.checked;
        settings.enableArrowKeys = formRefs.enableArrowKeys.checked;
        settings.enableWASD = formRefs.enableWASD.checked;
        settings.keyboardJoystickIndicator = formRefs.keyboardJoystickIndicator.checked;
        settings.enableWeapons = formRefs.enableWeapons.checked;
        const picked = formRefs.handednessRadios.find(r => r.checked);
        settings.handedness = picked ? picked.value : 'right';
        if(!settings.enableArrowKeys && !settings.enableWASD) {
            keyState.up = keyState.down = keyState.left = keyState.right = false;
        }
        if(!settings.enableJoystick) {
            joystickActive = false;
            joystickTouchId = null;
            joystickKnob.x = joystickBase.x;
            joystickKnob.y = joystickBase.y;
        }
        setControlPositions();
    }

    function setupSettingsPanel() {
        formRefs.enableJoystick.addEventListener('change', syncSettingsFromUI);
        formRefs.enableArrowKeys.addEventListener('change', syncSettingsFromUI);
        formRefs.enableWASD.addEventListener('change', syncSettingsFromUI);
        formRefs.keyboardJoystickIndicator.addEventListener('change', syncSettingsFromUI);
        formRefs.enableWeapons.addEventListener('change', syncSettingsFromUI);
        formRefs.handednessRadios.forEach(radio => radio.addEventListener('change', syncSettingsFromUI));
    }

    // Keyboard controls for desktop browsers
    window.addEventListener('keydown', function(e) {
        switch(e.key) {
            case 'ArrowUp':
                if(!settings.enableArrowKeys) return;
                keyState.up = true;
                break;
            case 'w':
            case 'W':
                if(!settings.enableWASD) return;
                keyState.up = true;
                break;
            case 'ArrowDown':
                if(!settings.enableArrowKeys) return;
                keyState.down = true;
                break;
            case 's':
            case 'S':
                if(!settings.enableWASD) return;
                keyState.down = true;
                break;
            case 'ArrowLeft':
                if(!settings.enableArrowKeys) return;
                keyState.left = true;
                break;
            case 'a':
            case 'A':
                if(!settings.enableWASD) return;
                keyState.left = true;
                break;
            case 'ArrowRight':
                if(!settings.enableArrowKeys) return;
                keyState.right = true;
                break;
            case 'd':
            case 'D':
                if(!settings.enableWASD) return;
                keyState.right = true;
                break;
            case ' ':
                attackPressed = true;
                break;
            default:
                return;
        }
        e.preventDefault();
    });

    window.addEventListener('keyup', function(e) {
        switch(e.key) {
            case 'ArrowUp':
                if(!settings.enableArrowKeys) return;
                keyState.up = false;
                break;
            case 'w':
            case 'W':
                if(!settings.enableWASD) return;
                keyState.up = false;
                break;
            case 'ArrowDown':
                if(!settings.enableArrowKeys) return;
                keyState.down = false;
                break;
            case 's':
            case 'S':
                if(!settings.enableWASD) return;
                keyState.down = false;
                break;
            case 'ArrowLeft':
                if(!settings.enableArrowKeys) return;
                keyState.left = false;
                break;
            case 'a':
            case 'A':
                if(!settings.enableWASD) return;
                keyState.left = false;
                break;
            case 'ArrowRight':
                if(!settings.enableArrowKeys) return;
                keyState.right = false;
                break;
            case 'd':
            case 'D':
                if(!settings.enableWASD) return;
                keyState.right = false;
                break;
            case ' ':
                attackPressed = false;
                break;
            default:
                return;
        }
        e.preventDefault();
    });

    function drawHat(x, y, style) {
        gameCtx.fillStyle = style.hatColor;
        gameCtx.beginPath();
        if(style.hatType === 'triangle') {
            gameCtx.moveTo(x, y - style.headRadius);
            gameCtx.lineTo(x - style.headRadius, y + style.headRadius);
            gameCtx.lineTo(x + style.headRadius, y + style.headRadius);
        } else if(style.hatType === 'square') {
            gameCtx.rect(x - style.headRadius, y - style.headRadius, style.headRadius * 2, style.headRadius * 2);
        } else {
            // pentagon
            const r = style.headRadius + 2;
            for(let i = 0; i < 5; i++) {
                const angle = (-Math.PI / 2) + (i * 2 * Math.PI / 5);
                const px = x + Math.cos(angle) * r;
                const py = y + Math.sin(angle) * r;
                if(i === 0) gameCtx.moveTo(px, py);
                else gameCtx.lineTo(px, py);
            }
        }
        gameCtx.closePath();
        gameCtx.fill();
    }

    function drawWeapon(enemy, torsoTopY, torsoBottomY) {
        const s = enemy.style;
        const armY = enemy.y - 2;
        const handX = enemy.hand === 'left' ? enemy.x - s.armLength : enemy.x + s.armLength;
        const dir = enemy.hand === 'left' ? -1 : 1;
        gameCtx.lineWidth = 3;
        if(s.weapon === 'gloves') {
            gameCtx.fillStyle = '#d35400';
            gameCtx.beginPath();
            gameCtx.rect(handX - 6, armY - 6, 12, 12);
            gameCtx.fill();
        } else if(s.weapon === 'sword') {
            gameCtx.strokeStyle = '#95a5a6';
            gameCtx.beginPath();
            gameCtx.moveTo(handX, armY);
            gameCtx.lineTo(handX + dir * 18, armY - 14);
            gameCtx.stroke();
            gameCtx.strokeStyle = s.bodyColor;
            gameCtx.beginPath();
            gameCtx.moveTo(handX, armY);
            gameCtx.lineTo(handX + dir * 6, armY + 6);
            gameCtx.stroke();
        } else if(s.weapon === 'cup') {
            gameCtx.fillStyle = '#bdc3c7';
            gameCtx.beginPath();
            gameCtx.rect(handX - 5, armY - 7, 10, 14);
            gameCtx.fill();
            gameCtx.strokeStyle = '#7f8c8d';
            gameCtx.beginPath();
            gameCtx.arc(handX + dir * 5, armY, 4, Math.PI * 0.25 * (dir === 1 ? 1 : -1), Math.PI * 0.75 * (dir === 1 ? 1 : -1), dir === -1);
            gameCtx.stroke();
        }
        gameCtx.lineWidth = 2;
    }
    
    // Circle collision detection
    function circleCollide(x1,y1,r1, x2,y2,r2) {
        const dx = x1 - x2;
        const dy = y1 - y2;
        const r = r1 + r2;
        return dx*dx + dy*dy <= r*r;
    }
    
    // Update game state
    function update() {
        // Move player based on joystick and keyboard
        let moveX = 0;
        let moveY = 0;

        if(settings.enableJoystick && joystickActive) {
            const vx = joystickKnob.x - joystickBase.x;
            const vy = joystickKnob.y - joystickBase.y;
            const vlen = Math.sqrt(vx*vx + vy*vy);
            if(vlen > 0) {
                moveX += vx / vlen;
                moveY += vy / vlen;
            }
        }

        const keyX = (keyState.right ? 1 : 0) - (keyState.left ? 1 : 0);
        const keyY = (keyState.down ? 1 : 0) - (keyState.up ? 1 : 0);
        if(keyX !== 0 || keyY !== 0) {
            const klen = Math.sqrt(keyX*keyX + keyY*keyY);
            moveX += keyX / klen;
            moveY += keyY / klen;
            if(settings.enableJoystick && settings.keyboardJoystickIndicator && !joystickActive) {
                const indicatorX = joystickBase.x + (keyX / klen) * joystickRadius;
                const indicatorY = joystickBase.y + (keyY / klen) * joystickRadius;
                joystickKnob.x = indicatorX;
                joystickKnob.y = indicatorY;
            }
        } else if(!joystickActive) {
            joystickKnob.x = joystickBase.x;
            joystickKnob.y = joystickBase.y;
        }

        const mlen = Math.sqrt(moveX*moveX + moveY*moveY);
        if(mlen > 0) {
            player.x += (moveX / mlen) * maxSpeed;
            player.y += (moveY / mlen) * maxSpeed;
        }
        // Keep player inside screen
        player.x = Math.max(player.radius, Math.min(window.innerWidth - player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(window.innerHeight - player.radius, player.y));
        
        // Move enemies
        for(let enemy of enemies) {
            enemy.x += enemy.dx;
            enemy.y += enemy.dy;
            if(enemy.x < enemy.size || enemy.x > window.innerWidth - enemy.size) enemy.dx *= -1;
            if(enemy.y < enemy.size || enemy.y > window.innerHeight - enemy.size) enemy.dy *= -1;
        }
        clampEnemiesToScreen();
        
        // Handle collisions between player and enemies
        for(let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            if(circleCollide(player.x, player.y, player.radius, e.x, e.y, e.size)) {
                if(attackPressed && mission === 1) {
                    // eliminate enemy
                    enemies.splice(i, 1);
                    killCount++;
                } else {
                    // bounce enemy away
                    e.dx *= -1;
                    e.dy *= -1;
                }
            }
        }
        
        // Mission logic
        if(mission === 1 && killCount >= 5) {
            mission = 2;
        }
        if(mission === 2) {
            // If player enters target zone, reset game
            if(player.x > targetZone.x && player.x < targetZone.x + targetZone.size
               && player.y > targetZone.y && player.y < targetZone.y + targetZone.size) {
                mission = 1;
                killCount = 0;
                initEnemies();
            }
        }
    }
    
    // Draw game elements on gameCanvas
    function drawGame() {
        // Clear screen
        gameCtx.fillStyle = '#ffffff';
        gameCtx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        // Draw target zone
        if(mission === 2) {
            gameCtx.fillStyle = 'lightgreen';
            gameCtx.fillRect(targetZone.x, targetZone.y, targetZone.size, targetZone.size);
        }
        // Draw player (simple stick figure)
        gameCtx.fillStyle = player.color;
        // head
        gameCtx.beginPath();
        gameCtx.arc(player.x, player.y - 15, 5, 0, Math.PI*2);
        gameCtx.fill();
        // body
        gameCtx.beginPath();
        gameCtx.moveTo(player.x, player.y - 10);
        gameCtx.lineTo(player.x, player.y + 5);
        gameCtx.stroke();
        // arms
        gameCtx.beginPath();
        gameCtx.moveTo(player.x - 8, player.y - 5);
        gameCtx.lineTo(player.x + 8, player.y - 5);
        gameCtx.stroke();
        // legs
        gameCtx.beginPath();
        gameCtx.moveTo(player.x, player.y + 5);
        gameCtx.lineTo(player.x - 5, player.y + 15);
        gameCtx.moveTo(player.x, player.y + 5);
        gameCtx.lineTo(player.x + 5, player.y + 15);
        gameCtx.stroke();
        // Draw enemies (stick figure bad guys)
        for(let enemy of enemies) {
            const s = enemy.style;
            const torsoTopY = enemy.y - s.bodyLength * 0.5;
            const torsoBottomY = enemy.y + s.bodyLength * 0.5;
            gameCtx.strokeStyle = s.bodyColor;
            gameCtx.fillStyle = s.bodyColor;
            gameCtx.lineWidth = 2;

            // head
            gameCtx.beginPath();
            gameCtx.arc(enemy.x, torsoTopY - s.headRadius, s.headRadius, 0, Math.PI * 2);
            gameCtx.fill();

            // hat tied to type
            drawHat(enemy.x, torsoTopY - s.headRadius * 2, s);

            // torso
            gameCtx.beginPath();
            gameCtx.moveTo(enemy.x, torsoTopY);
            gameCtx.lineTo(enemy.x, torsoBottomY);
            gameCtx.stroke();

            // arms
            gameCtx.beginPath();
            gameCtx.moveTo(enemy.x - s.armLength, enemy.y - 2);
            gameCtx.lineTo(enemy.x + s.armLength, enemy.y - 2);
            gameCtx.stroke();

            // legs
            gameCtx.beginPath();
            gameCtx.moveTo(enemy.x, torsoBottomY);
            gameCtx.lineTo(enemy.x - s.legLength * 0.5, torsoBottomY + s.legLength);
            gameCtx.moveTo(enemy.x, torsoBottomY);
            gameCtx.lineTo(enemy.x + s.legLength * 0.5, torsoBottomY + s.legLength);
            gameCtx.stroke();
            if(settings.enableWeapons) {
                drawWeapon(enemy, torsoTopY, torsoBottomY);
            }
        }
        // Draw mission status text
        gameCtx.fillStyle = 'black';
        gameCtx.font = '16px sans-serif'; // mobile-friendly font size [oai_citation:7‡gamedevjs.com](https://gamedevjs.com/articles/best-practices-of-building-mobile-friendly-html5-games/#:~:text=the%20device%E2%80%99s%20tilt.%20,to%20tap%20on%20small%20screens)
        if(mission === 1) {
            gameCtx.fillText(`Mission: Eliminate 5 enemies (${killCount})`, 10, 20);
        } else {
            gameCtx.fillText('Mission: Reach the green zone', 10, 20);
        }
    }
    
    // Draw UI elements on uiCanvas
    function drawUI() {
        uiCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        // Draw joystick base
        uiCtx.globalAlpha = settings.enableJoystick ? 0.5 : 0.2;
        uiCtx.beginPath();
        uiCtx.arc(joystickBase.x, joystickBase.y, joystickRadius, 0, Math.PI*2);
        uiCtx.fillStyle = '#888';
        uiCtx.fill();
        // Draw joystick knob
        uiCtx.globalAlpha = settings.enableJoystick ? 1.0 : 0.3;
        uiCtx.beginPath();
        uiCtx.arc(joystickKnob.x, joystickKnob.y, 20, 0, Math.PI*2);
        uiCtx.fillStyle = '#444';
        uiCtx.fill();
        // Draw attack button
        uiCtx.globalAlpha = actionTouchId ? 0.7 : 0.5;
        uiCtx.beginPath();
        uiCtx.arc(actionButton.x, actionButton.y, actionButton.radius, 0, Math.PI*2);
        uiCtx.fillStyle = '#f00';
        uiCtx.fill();
    }
    
    function gameLoop() {
        update();
        drawGame();
        drawUI();
        requestAnimationFrame(gameLoop); // smooth animation loop [oai_citation:8‡stackoverflow.com](https://stackoverflow.com/questions/16191324/performance-problems-with-html5-canvas-in-some-mobile-browsers#:~:text=,nothing%20compared%20to%20native%20requestAnimationFrame)
    }

    // Start the game
    setupSettingsPanel();
    syncSettingsFromUI();
    resizeCanvas();
    initEnemies();
    gameLoop();
})();
</script>
</body>
</html>
