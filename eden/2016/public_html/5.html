<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.issued" content="2015-10-11T17:27:19.73" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.modified" content="2015-10-11T19:58:30.15" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.Bullet_20_Symbols { font-family:OpenSymbol; }
	.T1 { vertical-align:super; font-size:58%;}
	<!-- ODF styles with no properties representable as CSS -->
	{ }
	</style></head><body dir="ltr" style="max-width:8.5in;margin:0.7874in; margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; "><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Synchronization<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Why synchronize?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Problem<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Threads may share data<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Data consistency must be maintained<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Example<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Suppose a thread wants to withdraw 5$ from a bank account, and another thread wants to deposit 10$ to the same account<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>What should the balance be after the two transactions have been completed, and what might happen if the two transactions are executed concurrently?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Depending on order of operations, the balance could be the start -5, or the start + 10 instead of the start + 5.<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Need to ensure the orderly execution of cooperating threads<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Terminology<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Critical Section: CS is a section of code which reads or writes shared data<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Race condition: potential for interleaved execution of a critical section by multiple threads<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Results are non-deterministic<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Mutual exclusion: synchronizing mechanism used to avoid race conditions by ensuring exclusive execution of critical sections<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Deadlock: permanent blocking of threads<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Livelock: execution but no progress<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Starvation: one or more threads have been denied resources<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Synchronization Primatives<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Most common<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Locks (mutual exclusion)<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Condition Variables<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Semaphores<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Monitors<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Barriers<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Need<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Semaphores<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Locks and condition variables<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Locks<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>REQUIRED for Mutual Exclusion<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>No assumptions on hardware: speed, # of processors<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Mutual exclusion is maintained – that is only one thread at a time can be executing inside a CS<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Execution of a CS takes a finite time<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>A thread not in the CS cannot prevent other threads to enter the CS<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Entering the CS cannot be delayed indefinitely: no deadlock or starvation<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Mutual exclusion = want to be the only thread modifying a set of data items<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Can look at it as exclusive access to data items or to a piece of code<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Have three components<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Acquire, Release, Waiting<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Implementing locks at user-level<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Why? <span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>It's expensive to enter the kernel<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What's the issue?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Can't disable interrupts<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Many software algorithms exist for mutual exclusion<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Disadvantages: it's very difficult to get correct<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What do we do?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Simple solution with a little bit of help from the hardware<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Atomic read-modify-write instructions<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Test and set<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Automatically read a variable, if the value of the variable is currently 0, set to 1<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Fetch and increment<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Atomically return the current value of a memory location and increment the value in memory by 1<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Compare and swap<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Atomically compare the value of a memory location with an old value, and if it's the same then replace with a new value<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Modern architectures perform atomic operations inside the cache<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Implementing a spin lock with Test and Set<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Test and set is guaranteed to not generate traffic unnecessarily, but there's still traffic after a release and no ordering guarantees<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>spin_acquire(lock)<br/><span style="margin-left:0cm"/>{<br/><span style="margin-left:0cm"/>        while(1){<br/><span style="margin-left:0cm"/>                while (lock == LOCKED){<br/><span style="margin-left:0cm"/>                if(test-and-set(lock) == UNLOCKED) break;<br/><span style="margin-left:0cm"/>                }<br/><span style="margin-left:0cm"/>}<br/><span style="margin-left:0cm"/>spin_release(lock){<br/><span style="margin-left:0cm"/>        lock = UNLOCKED;<br/><span style="margin-left:0cm"/>}<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Ticket lock using fetch and increment<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Each thread gets a ticket from variable next-ticket<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Now-serving variable holds ticket of current lock holder<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Think about how to implement acquire and release<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Many other spin lock implementations exist        <span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Implementing (Spin) Barriers<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Centralized barrier:<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Each thread increments a shared counter upon arriving<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Each thread polls the shared counter until all have arrived<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Barrier(num_threads){<br/><span style="margin-left:0cm"/> if(fetch and increment (counter) == num_threads){<br/><span style="margin-left:0cm"/> counter = 0;<br/><span style="margin-left:0cm"/> else<br/><span style="margin-left:0cm"/> while(counter!=0);}}<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Note that consecutive barriers may mess with the shared counter, and there may be contention for the shared counter.<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Sense Reversal<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Odd barriers wait for a flag to go from true to false, even wait for a flag to go from false to true<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Still suffers from contention<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Possible solution: combining tree barrier with sense reversal<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Writes done in a tree, only n-degree threads can write to same counter<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Last arrival at each level goes further up<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Thread that arrives at the root wakes up the others by changing the sense variables on which they are spinning<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>What do we do while waiting?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>We've considered two types of primitives<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Blocking<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>OS or RT system de-schedules waiting threads<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Spinning <span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Waiting threads keep testing location until it changes value<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Doesn’t quite work in single threaded uniprocessors<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Spinning vs blocking becomes an issue in multithreaded processors and multiprocessors<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>There is a tradeoff of blocking vs expected waiting time<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Condition Variables<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>A condition variable is always associated with<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>A condition and a lock<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>They are typically used to wait for the condition to take on a certain value<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>There are three main operations<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Wait(Lock L)<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Release the lock<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Put thread object on wait queue of this condvar object<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Yield the CPU to another thread<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>When awakened by the system, reacquire the lock and return<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Signal()<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If at least 1 thread is sleeping on cond_var, wake 1 up. Otherwise, no effect<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Waking up a thread means changing its state to ready and moving the thread object to the run queue<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Broadcast()<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If 1 or more threads are sleeping on cond_var wake everyone up<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Otherwise, nothing<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Producer/Consumer Example<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Imagine a web server with the following architecture<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>One producer thread listens for client http requests<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>When a request is received, the producer enqueues it on a circular request queue with finite capacity if there is room<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>A number of consumer threads service the queue as follows<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Remove the 1<span class="T1">st</span> request from the queue if there is a request<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Read data from disk to service the request<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>How can they synchronize?<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Implementing condition variables<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Condition variables are implemented using locks<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Implementation is tricky because it involved multiple locks and scheduling queue<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Implemented in the OS or runtime thread systems because they involve scheduling operations such as sleep/wakeup<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Semaphores<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Synchronized counting variables<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Formally, a semaphore is comprised of an integer value and two operations<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>P()<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>While value = 0, sleep<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Decrement value<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>V()<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Increment value<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>If there are any threads sleeping waiting for value to become non-zero, wakeup at least one thread<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Using Semaphores<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Can be used to implement mutual exclusion<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Use binary semaphore, initialize the counter to 1<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>P == lock acquired, V == lock released<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>General semaphores with the help of a binary semaphore can be used in producer-consumer types of synchronization problems ***important***<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Implementing Semaphores ***important***<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Can you see how to implement semaphores given locks and condition variables?<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Can you see how to implement locks and condition variables given semaphores?<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Monitors<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Semaphores have a few limitations<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Unstructured, difficult to program correctly<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Monitors eliminate these limitations and are as powerful as semaphores<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>A monitor consists of a software module with one or more procedures, an initialization sequence, and local data (can only be accessed by procedures)<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Only one process can execute within the monitor at any one time (mutex) → entry queue<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Synchronization within the monitor implemented with condition variables (wait/signal) → one queue per condition variable<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Syntax<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Monitor monitor-name{<br/><span style="margin-left:0cm"/>shared var declarations<br/><span style="margin-left:0cm"/> procedure body P1(){<br/><span style="margin-left:0cm"/> }<br/><span style="margin-left:0cm"/> ….<br/><span style="margin-left:0cm"/> procedure body Pn(){<br/><span style="margin-left:0cm"/> }<br/><span style="margin-left:0cm"/>{<br/><span style="margin-left:0cm"/> initialization code<br/><span style="margin-left:0cm"/>}<br/><span style="margin-left:0cm"/>}<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Deadlock<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Can occur whenever multiple parties are competing for exclusive access to multiple resources<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How can we avoid deadlocks?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Prevention<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Design a system without one of the conditions that cause deadlocks<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>To prevent circular wait, impose a strict ordering on resources <span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>If you need to lock A and B, always lock A then B<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Avoidance<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Banker's Algorithm<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Deny requests that may lead to unsafe states<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Running the algorithm on all resource requests is expensive<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span> Detection/recovery<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Check for circular wait periodically. If the wait is found, abort all deadlocked processes<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Checking for circular wait is expensive<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Conditions for a deadlock<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Mutex<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Hold and wait<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>A thread/process that needs a resource that is currently taken holds on to the resources it already has and waits for the resource<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>No preemption<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>A thread/process never has a resource that it is holding taken away from it<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Circular wait<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Banker's Algorithm<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Idea: reject resource allocation requests that might leave the system in an unsafe state<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>A state is safe if the system can allocate resources to each process (up to it's maximum) in some order and still avoid a deadlock. Note that not all unsafe states are deadlock states<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Conservative algorithm, it simply avoids unsafe states altogether<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span><span class="odfLiEnd"/> </p></li></ul></li></ul></body></html>