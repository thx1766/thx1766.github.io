<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.issued" content="2015-10-11T15:20:17.61" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.modified" content="2015-10-14T14:25:50" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P2 { font-size:12pt; font-family:Times New Roman; writing-mode:page; font-weight:normal; }
	.Bullet_20_Symbols { font-family:OpenSymbol; }
	.T1 { font-weight:bold; }
	.T2 { font-weight:normal; }
	<!-- ODF styles with no properties representable as CSS -->
	{ }
	</style></head><body dir="ltr" style="max-width:8.5in;margin:0.7874in; margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; "><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span><span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Processes<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>von Neuman Model<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Both text (program) and data reside in memory<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Execution cycle<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Fetch → Decode → Execute<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Global Variables<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How do we deal with global variables?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Allocate some space in memory for them<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Done by the compiler at compile time<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>A reference to a variable is just an access to the variable's location in memory <span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Local Variables<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How do we handle local variables?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Allocate a new location to a variable when it's containing function is called at run time <span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Convention is to allocate storage for these variables in the stack (control stack)<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Pop the stack when returning from a function, storage is no longer needed<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Code of allocation/deallocation of space on the stack is generated by the compiler at compile time <span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>What about “new” objects?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Eg: foo foo_obj = new foo;<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>foo_obj is really a pointer to a foo object<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Memory location allocated for foo_obj from the stack whenever the containing function is called (in this case let's say it was main())<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Where does the object created by “new foo” exist?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Is the stack an appropriate place for this object?<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Data Access<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How do we find dynamically allocated data on the stack?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Designate a register as the stack pointer<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Stack pointer always points to the current <span class="T1">activation record</span><span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Stack pointer is set at entry to a function<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Code for setting stack pointer is generated by the compiler<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Local variables and parameters are referenced as offsets from the stack pointer<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Activation Records<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>We've only talked about allocation of local variables on the stack<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The activation record is also used to store:<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Parameters<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>A pointer to the beginning of the previous activation record<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>The return address<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Run time storage organization<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Each variable must be assigned a storage class<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Global (static variables)<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Allocated in globals region at compile time<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Routine local variables and parameters<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Allocated dynamically on stack<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Dynamically created objects (using new/malloc)<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Allocated from heap<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Live beyond the invocation of a routine<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Garbage collected when no longer “alive”<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>What'd all that have to do with Processes?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Process = system abstraction for the set of resources required for execution of a program<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Also a running instance of a program, as well as the memory image + registers' content (+ IO state)<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span><span class="T2">The stack and registers' content represent the </span><span class="T1">execution context</span><span class="T2"> or </span><span class="T1">thread of control</span><span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>What about the OS?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>One of the functions of an OS is to provide a virtual machine interface that makes programming the machine easier<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>A process memory image must also contain the OS<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>OS data space is used to store things like file descriptors for files being accessed by the process, status of IO devices, etc<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Process Control Block<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Each process has per-process state maintained by the OS<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Identification: process, parent process, user, group, etc<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Execution contexts: threads<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Address space: virtual memory<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>IO state: file handles (file system), communication endpoints (network), etc<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Accounting information<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>For each process, this state is maintained in a process control block (PCB)<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>This is just data in the OS data space<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Think of it as objects of a class<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Process Creation<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How do we create a process? <span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>With a system call<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>In UNIX, a process can create another process using the fork() system call<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>int pid = fork();<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The creating process is called the parent, and the new process is called the child<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The child process is created as a copy of the parent process<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Process image and process control structure copied<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Identification and scheduling state not copied<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Parent and Child processes run in different address spaces<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>No memory sharing by default<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Process creation is expensive because of the copying<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The exec() call is provided for newly created process to run a different program than that of the parent<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Process death (or murder)<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>One process can wait for another process to finish using the wait() system call<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Can wait for a child to finish as shown in the example<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Can also wait for an arbitrary process if we know it's PID<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Can kill another process using the kill() system call<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>What happens when kill() is invoked?<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>What if the victim process doesn't want to die?<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Signals<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>User program can invoke OS services by using system calls<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What if the program wants the OS to notify it asynchronously when some event occurs?<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Signals are a UNIX mechanism for OS to notify a user program when an event of interest occurs<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Potentially interesting events are predefined (seg fault, message arrival, kill, etc)<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>When interested in “handling” a particular event (signal), a process indicates its interest to the OS and gives the OS a procedure that should be invoked in the upcall<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>When an event of interest occurs<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>The kernel handles the event first, then modifies the process's stack to look as if the process's code made a procedure call to the signal handler<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Puts an activation record on user-level stack corresponding to the event handler<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>When the user process is scheduled next it executes the handler first<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>From the handler, the user process returns to where it was when the event occurred<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Process: Summary<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>An instantiation of a program<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>System abstraction: the set of resources required for executing a program<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Execution contexts<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Address space<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>File handles, communication endpoints, etc<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Historically, all of the above were lumped into a single abstraction<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>More recently, split into several abstractions<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Threads, address space, protection domain, etc<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>OS process management<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Supports user creation of processes and inter-process communication (IPC)<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Allocates resources to processes according to specific policies<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Interleaves the execution of multiple processes to increase system utilization<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span><span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li></ul></body></html>