<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.issued" content="2015-10-10T14:54:37.98" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.modified" content="2015-10-13T18:50:17.55" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P2 { font-size:12pt; font-family:Times New Roman; writing-mode:page; font-weight:normal; }
	.Bullet_20_Symbols { font-family:OpenSymbol; }
	.T1 { font-weight:bold; }
	.T2 { font-weight:normal; }
	<!-- ODF styles with no properties representable as CSS -->
	{ }
	</style></head><body dir="ltr" style="max-width:8.5in;margin:0.7874in; margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; "><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Architecture Tour for Operating Systems<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Fetch-Decode-Execute Loop<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>View the computer as a large <span class="T1">general purpose </span><span class="T2">calculator</span><span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Want to program it for multiple functions<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>All Von Neumann computers follow the same loop<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Fetch an instruction from memory<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Decode the instruction to figure out what to do<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Execute the instruction and store the result<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Instructions are not complicated<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>ie: add the value of a memory cell by 1<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>The Program Counter<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Where is the next instruction held in the machine? (It's in here, spoiler)<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>A simple memory cell in the CPU, known as the “program counter” (or simply the PC), contains the address of the next instruction <span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Special purpose memory in the CPU and all devices are called registers<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Naive fetch cycle: increment the PC by the instruction length after each execute<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Assumes all instructions are the same length<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Memory Indirection<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How can we access array elements efficiently if all we can do is name a cell?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Modify the operand to allow for fetching an operand “through” a memory location<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Ex: Load[5], 2 means fetch the contents of the cell whose address is in cell 5 and put it into cell 2<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>This is known as indirection<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Fetch the contents of the cell pointed to by the cell in the opcode<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Steal an operand bit to signify if an indirection is desired<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Conditionals and Looping<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>primitive computers only follow linear instructions<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Breakthrough in early computing was the addition of branching conditionals<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>These instructions modify the program counter<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Conditional Instructions<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If the content of this cell is [positive, not zero, whatever], then execute the instruction (or not)<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Branch Instructions<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If the content of this cell is[zero, nonzero, etc], set the PC to this location<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Jump is an unconditional branch<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Registers<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Architecture Rule: large memories are slow, small ones are fast<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>But everyone wants more of it<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Solution: put small amount of memory in the CPU for faster operation <span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Most programs work only on small chunks of memory in a given time period, this is known as locality<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If we cache the contents of a small number of memory cells in the CPU memory, we might be able to execute many instructions before having to access memory<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Small memory in CPU named separately in the instructions from the main memory<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Small memory in CPU = registers, large memory = main memory<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Most CPUs have 16-32 general purpose registers<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>All of these look the “same”, they're a combo of operators, operands and destinations<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Only memory operations possible in register only machines are load from and store in memory<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Operations 100-1000 times faster when operands are in registers compared to when they are in memory<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Save instruction space as well<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Only address 16-32 registers, not a GB of memory<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Abstracting the Machine<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Bare hardware provides a computation device<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How do we share this expensive piece of equipment between multiple users?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Sign up during certain hours?<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Give the program to an operator?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Run it → give you results<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Duh, the Operating System!<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Need hardware support to “virtualize” machine<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Architecture Features for the OS<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What are some mechanisms that hardware designers add to allow OS designers to abstract the basic machine in software?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Processor modes<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Exceptions<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Traps<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Interrupts<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>These require modifications to the basic fetch-decode-execture cycle in hardware<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Processor Modes<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>OS code is stored in memory (von neumann model)<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>What if a user program modifies this OS code or data?<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Modes of Operation <span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Instructions can be executed in user mode or system mode<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Special register holds what mode the CPU is in<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Certain instructions can only be executed when in system mode<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Likewise, certain memory locations can only be written to when in system mode<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Only OS code is executed in system mode<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Only OS can modify it's memory<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>The mode register can only be modified in system mode<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>How can we protect the OS from users?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>All addresses &lt;100 are reserved for OS use<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Mode register provided<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>zero = sys = cpu is executing the OS (in sys mode)<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>one = usr = cpu is executing in user mode<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Hardware does this check<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>On every fetch, if the mode bit is user, and the instruction address is less than 100 don't execute the instruction<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span><span class="T2">When accessing operands, if the mode bit is USR and the operand address is less </span><span class="T2">than 100, do not execute the instruction </span><span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Mode register can only be set if mode is SYS<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Exceptions<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What happens when a user program tries to access memory holding the operating system code or data?<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>An exception occurs when the CPU encounters an instruction that cannot be executed<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Need a modified fde loop to jump to a known location in the OS when an exception happens<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Different errors jump to different places in the OS (vectored)<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Access Violations<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Notice both instruction fetch from memory and data access must be checked<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Execute phase must check both operands<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Execute phase must check again when performing an indirect load<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>This is a very primitive memory protection scheme<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Recovering from Exceptions<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The OS can figure out what caused the exception from the entry point<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>How can it figure out where in the user program the problem is?<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Solution: another register, the Program Counter<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>When an exception occurs, save the current PC to PC' before loading the PC with a new value<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>OS can examine the PC' and perform some recovery action<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Stop user program and print error message, error at address PC'<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Run a debugger<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Traps<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How does a user program legitimately access OS services?<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>A trap is a special instruction that forces the PC to a known address and sets the mode into system mode<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Unlike exceptions traps carry some arguments to the OS<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Foundation of the system call<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How does the OS know which service the user program wants to invoke on a trap?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>User program passes to the OS a number that encodes which OS service is desired<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Most CPU's have a convention for passing the trap ID in a set of registers<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Returning from a Trap<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How do we get back into user mode and the user's code after a trap?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Use two instructions?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Set mode register = 1 then set the PC?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>After the mode bit is set to 1 we get an exception<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Set the PC then the mode bit?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Jump to “user-land” then in kernel mode<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Most machines have a return from exception instruction <span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>A single hardware instruction that can:<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Set the PC to PC', and set the mode bit to user mode<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Traps and exceptions use the same mechanism (RTE)<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Interrupts<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span><span class="T2">How can we force the CPU back into system mode if the user program is off computing </span><span class="T2">something?</span><span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>An interrupt is an external event that causes the CPU to jump to a known address<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Entry Points<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Entry points are a jump to some code block in the OS<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>All real OS's have a set of entry points for exceptions, traps, and interrupts<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Sometimes they are combined and software has to figure out what happened<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Saving and Restoring Context<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>When an entry to the OS happens, we want to start executing the correct routine (handler) then return to the user program so it can continue normal execution<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Can't just start using the registers in the OS <span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Solution: save/restore the user context<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Use the OS memory to save all the CPU state<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Before returning to user, reload all the registers and execute a return from exception instruction<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Input/Output<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How can humans get at the data? How do we load programs? What happens if I turn the machine off? Can I send the data to another machine?<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Solution: add devices to perform these tasks<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Keyboards, mice, graphics cards, disk drives, network cards<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Simple I/O Example: A Network Card<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Has 2 registers<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>A store into the “transmit” register sends the byte over the wire<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>A load from the “receive” register reads the last byte that was read from the wire<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How does the CPU access these registers?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Map them into address space!<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>An instruction the accesses memory cell 98 actually accesses the transmit register instead of memory, an instruction that accesses memory cell 99 actually accesses the receive register<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>These registers are said to be memory mapped<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Why memory-mapped registers?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>“Stealing” memory space for device registers has two functions<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Allows protection: only OS can access the device<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>User programs must trap into the OS to access IO devices because of the normal protection mechanisms in the processor <span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>OS can control devices and move data to/from devices using regular load and store instructions<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>No changes to instruction set required<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>This is known as programmed IO<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Status Registers<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How does the OS know if something new has arrived? How does it know when the last byte was submitted so it can send another one?<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>A status register holds the state of the last IO operation <span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Our sample network card has 1 status register<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>To transmit, OS writes a byte into the TX register (transmit register) and sets bit 0 of the status register to 1. When successfully transmitted, the 0 bit of the status register is set back to 0<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>When the card receives a byte, it puts the byte in the RX register (receive register) and sets bit 1 of the status register to 1. After the OS has read the data, the 1 bit of the status register is set back to 0.<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Interrupt driven IO<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Polling can waste CPU cycles<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>On transmit, CPU slows to speed of the device<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Can't block on receive, so tie polling to clock, but it's wasted if no RX data<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Use interrupts to avoid wasting time!<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>When network has data to receive, signal an interrupt<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>When data is done transmitting, signal an interrupt <span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Polling vs Interrupts<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Why poll at all?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Interrupts have a high overhead<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Stop processor, figure out what caused interrupt, save user state, process request<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Key factor is frequency of IO vs interrupt overhead<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Direct Memory Access (DMA)<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Problem with programmed IO, CPU must load/store all the data from/into device registers<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Data is probably in memory anyways!<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Solution: more hardware to allow the device to read and write memory just like the CPU<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Base + bound or base+count registers in the device<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Set base + count register<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Set the start transmit register<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>IO device reads memory from base<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Interrupts when done<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>PIO vs DMA<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Lower overhead for PIO in comparison to DMA<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>PIO is a check against the status register, then send or receive<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>DMA must set up base, count, start transfer take an interrupt <span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>DMA is more efficient at moving data<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>PIO ties up CPU for entire length of the transfer<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Size of the transfer is the key factor in when to use PIO vs DMA<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>IO Design Space (Recap)<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Polling vs Interrupts<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>How does the device notify the processor an event happened?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Polling: device is passive, CPU must read/write a register<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Interrupt: device signals CPU via an interrupt <span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Programmed IO vs DMA<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>How does the device send and receive data?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>PIO: CPU must use load/store into the device<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>DMA: Device reads and writes memory <span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>How to boot?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How does a machine start the operating system?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Process of starting the OS is called booting<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Sequence of hardware+software events form the boot protocol<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Boot protocol in modern machines is a 3 stage process<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>CPU starts executing from a fixed address<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Firmware loads the boot loader<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Boot loader loads the OS<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Boot Protocol<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>CPU is hardwired to start executing from a given address in memory <span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Memory address is typically mapped to a solid state persistent memory (ROM, EPROM, Flash etc)<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Persistent memory contains the boot code<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>This software is known as firmware<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>On x86 the starting address corresponds to the BIOS (basic input output system) boot entry point<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>This code reads 1 block from the disk drive. This block is loaded and then executed, the program is the boot loader<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The boot loader then loads the rest of the operating system from disk, at this point the OS is still not running<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Boot loader can know about multiple OS's, can know about multiple versions of same OS<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Why have a Boot Protocol?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Separate the OS from the hardware instead of storing in persistent memory <span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Multiple OS's or different versions of same OS<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Want to boot from different devices (security via a network boot)<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>OS is large, wouldn't work as firmware<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Multi CPU Chip Multiprocessors<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>SMP (simple scheme): more than one CPU on the same bus<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Memory is shared amount CPU's – cache coherence between LLCs<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Bus contention increases – does not scale<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Alternative (non-bus) system interconnect – complex and expensive<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>SMPs naturally support single-image operating systems<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>CC-NUMA Multiprocessors<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Non-uniform access to different memories<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Hardware allows remote memory accesses and maintains cache coherence<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Scalable interconnect and, more scalable than bus-based UMA systems<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Also naturally supports single-image operating systems<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Complex hardware coherence protocols<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Multicomputers<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Network of computers: share-nothing (cheap)<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Distributed resources: difficult to program <span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Message passing, distributed file system<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Challenge: build efficient global abstraction in software<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></body></html>