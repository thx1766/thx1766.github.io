<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.issued" content="2015-10-12T14:41:10.18" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.modified" content="2015-10-13T11:15:28.38" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P2 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.Bullet_20_Symbols { font-family:OpenSymbol; }
	.T1 { vertical-align:super; font-size:58%;}
	.T2 { color:#222222; font-family:Segoe UI, Arial, sans-serif; font-size:10.5pt; letter-spacing:normal; font-style:normal; font-weight:normal; }
	.T3 { color:#222222; font-family:Segoe UI, Arial, sans-serif; font-size:10.5pt; letter-spacing:normal; font-style:normal; font-weight:normal; }
	.T4 { vertical-align:sub; font-size:58%;}
	<!-- ODF styles with no properties representable as CSS -->
	.T5 { }
	</style></head><body dir="ltr" style="max-width:8.5in;margin:0.7874in; margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; "><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Memory Management<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Hardware Caches<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Closer to the processor than the main memory<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Smaller and faster than the main memory<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Act as “attraction memory”<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Contain the value of main memory locations which were recently accessed (temporal locality)<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Transfer between caches and main memory is performed in units called cache blocks/lines<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Caches also contain the value of memory locations that are close to locations that were recently accessed (spatial locality)<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Mapping between memory and cache is mostly static<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Fast handling of misses<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Often L1 I-cache is separate from D-cache<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Memory Hierarchy<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What if we want to support programs that require more memory than what's available in the system?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Pretend we have something bigger (virtual memory)<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Paging<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>A page is a cacheable unit of virtual memory<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The OS controls the mapping between pages of VM and memory<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>More flexible (at a cost)<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Starting from the beginning: two views of memory<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>View from the hardware – shared physical memory<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>View from the software – what a process “sees”: private virtual address space<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Memory management in the OS coordinates these two views<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Consistency: all address spaces should look “basically the same”<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Relocation: processes can be loaded at any physical address<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Protection: a process cannot maliciously access memory belonging to another process<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Sharing: may allow sharing of physical memory (must implement control)<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Dynamic Storage Allocation Problem<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How do we allocate processes in memory?<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>More generally, how do we satisfy a request of size n from a list of free holes?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>First-fit: allocate the first hole that is big enough<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Best-fit: allocate the smallest hole that is big enough; must search entire list, unless ordered by size. Produces the smallest leftover hole<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Worst-fit: allocate the largest hole, must also search the entire list. Produces the largest leftover hole.<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>First and best fit are better than worst fit in terms of speed and storage utilization<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Fragmentation<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>When entire processes are loaded into memory, there can be lots of unused memory space, but new jobs cannot be loaded<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Paging from fragmentation<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Idea: break processes into small, fixed-size chunks (pages), so that processes don't need to be contiguous in physical memory<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Segmentation<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Same idea, but now variable size chunks<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Virtual Memory<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>VM is the OS abstraction that provides the illusion of an address space that is contiguous and may be larger than the physical address space. <span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Thus, impossible to load entire processes to memory<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>VM can be implemented using either paging or segmentation but paging is presently most common<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Actually, a combination is usually used but the segmentation scheme is typically very simple<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>VM is motivated by both:<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Convenience<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>The programmer does not have to know where pages/segments are allocated in physical memory<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>The programmer does not have to deal with machines that have different amounts of physcial memory<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Fragmentation in multi-programming environments<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Hardware Translation<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Translation from virtual (aka logical) to physical addresses can be done in software but without protection<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Hardware support is needed for protection and performance<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Simplest solution with two registers: base and size<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Segmentation<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Segments are of variable size<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Translation done through a set of (base, size, state) tuples<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Segment table indexed by segment number<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>State<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Valid/invalid, access permission, reference, modified bits<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Segments may be visible to the programmer and can be used as a convenience for organizing the programs and data (eg code segment, global data segment)<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Paging<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Pages are of fixed size<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The physical memory corresponding to a page is called a page frame<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Translation done through a page table indexed by page number<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Each entry in a page table contains the frame number that the virtual page is mapped to and the state of the page in memory<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>State<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Valid/invalid, access permission, reference, modified, caching bits<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Transparent to the programmer<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Combined Paging and Segmentation<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Some MMUs combine paging with segmentation<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Virtual address: segment number + page number + offset<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Segmentation translation is performed first<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The segment entry points to a page table for that segment<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The page number portion of the virtual address is used to index the page table and look up the corresponding page frame number<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Segmentation not used much any more, so concentrate on paging<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>UNIX has a simple form of segmentation, but does not require any hardware support<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Translation Lookaside Buffers<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Translation on every memory access → must be fast<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What to do?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Caching<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Why does it work? We still have to lookup the page table entry and use it to do translation, right?<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Same as normal hardware cache – cache is smaller so can spend more $$ to make it faster<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Cache for page table entries is called the Translation Lookaside Buffer (TLB)<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Traditionally, fully associative and single-level, but are becoming set associative and multi-level<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Relatively small number of entries <span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Each TLB entry contains a page number and the corresponding PT entry<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>On each memory access, we look for the page → frame mapping in the TLB<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>TLB Miss<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>What happens if the TLB doesn't find the right PT entry?<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Evict an existing entry if doesn't have any free ones<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Replacements? Pseudo-LRU common today. One bit represents each internal node of a binary search tree; cache lines are the leaves. An access sets the bits to the other direction in the tree<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Bring in the missing entry from the PT<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>TLB misses can be handled in hardware or software<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Software allows application to assist in replacement decisions<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Where to store the Page Table?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>In memory<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Use memory to “enlarge” view of memory, leaving less physical memory<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>This kind of overhead is common<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>OS uses CPU cycles to implement abstraction of threads etc<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Have to know the proper tradeoff and understand common application characteristics. <span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Have to be common enough<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Can become large<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Page Table Structure<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Linear (conventional)<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Page tables can become extremely large<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Two level PT<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Page the page table. Saves space by only allocating 2<span class="T1">nd</span> level tables for virtual memory that has actually been allocated/touched<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Outer page table is always in memory<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Doesn't need a large chunk of physical memory<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Inverted PT<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Saves a lot of space, as it requires (a single chunk of) memory in proportion to the size of the physical address space. <span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Translation through a hash table structure<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If the entries in the outer PT name virtual addresses, we need one more level of translation<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Kernel can take advantage of paging<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Kernel's outer PT must remain in memory<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Other parts that cannot be paged:<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>page fault code, performance critical code (interrupt handlers), pages undergoing IO<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Multilevel Paging and Performance<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Since each level stored as a separate table in memory, translating a virtual address to a physical one may take n memory accesses for n-level page tables<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Caching still keeps performance reasonable<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>TLB hit rate of 98%, TLB access time of 2ns, memory access time of 120ns, 2-level PT yield<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>effective access time = .98 x (2+120) + .002 x (2 + 360) = 127 ns<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>only a 6% slowdown in memory access time<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Inverted Page Table<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>One entry for each real memory frame<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Entry consists of virtual address of the page stored in that frame, information about the process that owns the page<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>With hashing<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>This implementation of IPTs decreases the memory needed to store the PT, but increases the time needed to search it when a page reference occurs. For this reason, we do not use searching<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Can use a hash table to limit the search to one – or at most a few – PT entries. Under hashing, each PT entry also has to include a frame number and a chain pointer<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>The approach works by hashing the virtual page number + pid, the result indexes the hash table.  Each entry of the hash table stores a pointer to the first entry of the chain. The virtual page number of each entry is compared to the referenced page number and, on a match, the corresponding frame number is used.<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>How to deal with VM &gt; Physical Memory?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>If the address space of each process is &lt;= the size of the physical memory, no problem<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Still useful to tackle fragmentation and provide a contiguous address space<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>When VM &gt; physical memory<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Part stored in memory, part stored on disk<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Demand Paging<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>To start a process (program), just load the code page where the process will start executing<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>As the process references memory (instruction or data) outside of the loaded page, bring in as necessary<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Page faults<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What happens when the process references a page marked as invalid in the page table?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Page Fault Exception<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Check that reference is valid<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Find a free memory frame<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Read the desired page from disk<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Text and data pages come from disk. Stack and Heap pages are allocated in main memory first. Shared library pages may already be in main memory<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Update the page table entry to point to the frame<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Change the valid bit of the page to valid<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Restart the instruction that was interrupted by the exception<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What's the cost?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Exception → table check → find free memory frame or victim<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>About 200-600 microsecs<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Disk seek and read<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>10 ms<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Memory access<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>100 ns<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Total performance cost<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Degrades performance by ~100000, and doesn't even count additional things that could go wrong along the way<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Having too many page faults = bad, having no page faults = also bad<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If we want no more than 10% degradation, we can only have 1 page fault for every 1,000,000 memory accesses<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>OS better do good job of managing movement of data between secondary storage and main memory<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Page Replacement<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What if there's no free frame left on a page fault?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Free a frame that's currently being used<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Select the frame to be replaced (victim)<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Write the victim back to disk<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Change the page table to reflect the victim is now invalid<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Read the desired page into newly freed frame<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Change PT<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The new page is in the freed frame and is now valid<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Restart the faulting instruction<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Optimization<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Do not need to write the victim back if it has not been modified (need a dirty bit per page to check this)<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Highly motivated to find a good replacement policy<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>When evicting a page, how do we choose the best victim in order to minimize the page fault rate?<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>First in, First Out (FIFO)<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Be fair, let every page live in memory for about the same amount of time, then toss it<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Not a good method. <span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Least recently used (LRU)<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>On access to a page, timestamp it<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>When need to evict a page, choose one with oldest timestamp<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Good in practice, not easy to implement<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Not Frequently Used Replacement<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Have a reference bit (aka a use bit) and software counter for each page frame<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>At each clock interrupt, the OS adds the reference bit of each frame to it's counter and then clears the reference bit<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>When we need to evict a page, choose the frame with the lowest counter value<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Problems<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Doesn't forget anything, no sense of time – hard to evict a page that was referenced a lot sometime in the past but is no longer relevant<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Updating counters is expensive, especially since memory is getting rather large these days<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Can be improved with an aging scheme<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Counters are shifted right before adding the reference bit and the reference bit is added to the leftmost bit (rather than rightmost)<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Clock (Second-chance)<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Arrange the frames in a circle, with a clock hand (initially points to 1<span class="T1">st</span> frame)<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Hardware keeps 1 use bit per frame, sets the use bit on a memory reference to the corresponding frame<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If bit is not set, frame hasn't been used in a while<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>On a page fault<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Advance the clock hand<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Check the use bit<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>If it's a 1, it has been used recently. Set back to 0 and move on<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>If 0, this is our victim<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Can't always find a victim<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Nth Chance<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Similar to clock, except keep a counter as well as a use bit<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>On a page fault<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Advance the clock hand<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Check the use bit<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>If 1, clear and set counter to 0<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>If 0, increment the counter, if the counter &lt; N go on, otherwise, this is our victim<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Why?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>N larger → better approximation of LRU<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If N too large, can take too long to select a victim<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>A different implementation of 2<span class="T1">nd</span> chance<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Always keep a free list of some size n &gt; 0<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>On a page fault, if the free list has more than n frames, get a frame from the free list and read the desired page into the frame<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If the free list has only n frames, get a frame from it, read the desired page into the frame, then (in the background) choose a victim from the frames currently being used and put the frame on the free list<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>On a page fault, if the page is on a frame on the free list, don't have to read page back in<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Gets performance close to true LRU (good)<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Multi Programming Environment <span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Why?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Better utilization of resources<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Problems<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Mechanism (TLB?)<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Fairness?<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Over commitment of memory<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What's the potential problem?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Each process needs its working set to be in memory to perform well<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If too many process are running, the system can thrash<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>As the degree of multi programming increases, so does the CPU utilization – to a certain point, at which it drops exponentially<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Why does paging work? Locality<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Process migrates from one locality (working set) to another<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Why does thrashing occur?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Sum of the size of working sets &gt; total memory size<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Support for multiple processes<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>More than one address space can be loaded in memory<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>A CPU register points to the current page table<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>OS updates the register when context switching between threads from different processes<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Most TLBs can cache more than one PT<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Store the process id to distinguish between virtual addresses belonging to different processes<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>If TLB caches only one PT then it must be flushed at process switch time<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Switching between threads of different processes<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What if switching to a thread of a different process?<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Caches, TLB, page table, etc?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Caches<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Physical addresses: no problem<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Virtual addresses: cache must either have process tag or must flush cache on context switch<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>TLB <span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Each entry must have process tag or must flush TLB on switch<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Page table<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Page table pointer (register) must be reloaded on switch<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Resident Set Management<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>How many pages of a process should be brought in?<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Resident set size can be fixed or variable<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Replacement scope can be local or global<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Common schemes implemented in OS<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Variable allocation with global scope<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Simple, but replacement policy may not take working set issues into consideration<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>ie: may replace a page that is currently in the working set of a process<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Variable allocation with local scope<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>More complicated – from time to time, modify resident set size to approximate the working set size<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Working Set<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>The set of pages that have been referenced in the last window of time<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Size varies during execution of the process depending on locality of accesses<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>If the number of frames allocated to a process covers is working set, then the number of page faults is small<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Schedule a process only if there is enough free memory to load its working set<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Model<span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span><span class="T2">Δ</span>  = working set window = number of “virtual” time units (time elapsed while process is actually executing)<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>WSS<span class="T4">i</span><span class="T5"> (working set of process P</span><span class="T4">i</span><span class="T5">) = total # of pages referenced in most recent </span><span class="T3">Δ</span><span class="T5"> (varies in time)</span><span class="odfLiEnd"/> </p><ul><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span><span class="T5">if </span><span class="T3">Δ</span><span class="T5">  too small will not encompass entire locality</span><span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span><span class="T5">if </span><span class="T3">Δ</span><span class="T5">  too large, will encompass several localities</span><span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span><span class="T5">if </span><span class="T3">Δ</span><span class="T5">  → infinity, will encompass entire program </span><span class="odfLiEnd"/> </p></li></ul></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span><span class="T5">D = Σ(WSS</span><span class="T4">i</span><span class="T5">) = total demand for frames</span><span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>If D &gt; M (memory size) → thrashing<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Which process should we suspend?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Lowest priority, smallest resident set, last process activated...?<span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>An approach to keeping track of the working set<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Approximate with interval timer + a reference bit<span class="odfLiEnd"/> </p></li><li><p class="P1" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span><span class="T5">Example: </span><span class="T3">Δ</span><span class="T5"> = 10000 cycles</span><span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Timer interrupts after every 5000 cycles<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Keep in memory 2 bits for each page<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>When interrupted, copy and later reset all reference bits<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>If one of the copied reference bits = 1 → page in working set<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Not completely accurate<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Does not say when a reference occurs during the 5000 cycle interval<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Improvement?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>10 bits and interrupt every 1000 time units. Higher cost for more frequent interrupts, but more accurate.<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Another approach: Page Fault Frequency Scheme<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Establish an “acceptable” page fault rate<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>If the actual rate is too low (with respect to threshold), the process loses a frame<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>If the actual rate is too high (with respect to threshold), the process gains a frame<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>A counter per process stores virtual time between page faults<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>An upper threshold for the virtual time is defined<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>On a page fault, if the amount of time since the last fault is less than the threshold (page faults happening at a fast rate), the new page is added to the resident set<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>A lower threshold can be used in a similar fashion to discard pages from the resident set<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Issues with management policies we have discussed<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Deal with stable and transient (going from one locality or working set to another) periods in the same way<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>During transient periods, we would like to change timer intervals or paging rate thresholds, so that the resident set of the process does not grow excessively<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Summary<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Virtual memory is a way of introducing another level in our memory hierarchy in order to abstract away the amount of memory actually available on a particular system<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Important for “ease of programming”<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Allows contiguous address spaces that are larger than physical memory, as well as protection<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Can be implemented using paging (sometimes segmentation)<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Page fault is expensive so can't have too many of them<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Important to implement good page replacement policy<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Watch for thrashing!<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Other Considerations<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Prepaging vs demand paging<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Page size selection has to balance:<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Fragmentation<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Page table size<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>IO overhead<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Locality<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>TLB reach can be increased by using<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Larger pages<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>More entries<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Cache design issues<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Cache size and cache block size<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Mapping: physical/virtual caches, associativity<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Replacement algorithm: random or (pseudo) LRU<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Write policy: write through/write back <span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Overview: TLB Misses in Software<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>What can happen on a memory access (pageable PT and TLB misses handled in software)?<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>TLB miss → read page table entry<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>TLB miss → read kernel page table entry<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Page fault for necessary page of a process page table<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>All frames are used → need to evict a page → modify a process page table entry<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>TLB miss → read kernel page table entry<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Page fault for necessary page of process page table<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Go back to finding a frame<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Read in needed page, modify page table entry, fill TLB<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Segmentation<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Memory management scheme that supports user view of memory<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>A program is a collection of segments, a segment is a logical unit such as<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>main program, procedure, function, local variables, global variables, common block, stack, symbol table, arrays<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Architecture<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Logical address consists of a two tuple: &lt;segment number, offset&gt;<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Segment table – maps two dimensional physical addresses; each table has:<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>base – contains the starting physical address where the segments reside in memory<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>limit – specifies the length of the segment<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Segment Table Base Register (STBR) points to the segment table's location in memory<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Segment Table Length Register (STLR) indicates number of segments used by a program; segment number s is legal if s &lt; STLR<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Relocation<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Dynamic, by segment table<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Sharing<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Shared segments, same segment number<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Allocation<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>First/best fit, external fragmentation<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Protection<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>With each entry in segment table associate:<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Validation bit = 0 → illegal segment <span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Read/write/execute privileges<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Protection bits associated with segments; code sharing occurs at segment level<span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">•</span>Since segments vary in length, memory allocation is a dynamic storage-allocation problem<span class="odfLiEnd"/> </p></li></ul></li></ul></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">◦</span>Segmentation with Paging – MULTICS<span class="odfLiEnd"/> </p><ul><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Solved problems of external fragmentation and lengthy search times by paging the segments <span class="odfLiEnd"/> </p></li><li><p class="P2" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm">▪</span>Differs from pure segmentation in that the segment table entry contains not the base address of the segment, but rather the base address of a page table for this segment <span class="odfLiEnd"/> </p></li></ul></li></ul></li></ul></body></html>